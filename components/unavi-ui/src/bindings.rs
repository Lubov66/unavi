// Generated by `wit-bindgen` 0.20.0. DO NOT EDIT!
// Options used:
pub mod wired {
    pub mod input {

        #[allow(clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            pub type Vec3 = super::super::super::wired::math::types::Vec3;
            pub type Vec4 = super::super::super::wired::math::types::Vec4;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub enum HandSide {
                Left,
                Right,
            }
            impl ::core::fmt::Debug for HandSide {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        HandSide::Left => f.debug_tuple("HandSide::Left").finish(),
                        HandSide::Right => f.debug_tuple("HandSide::Right").finish(),
                    }
                }
            }

            impl HandSide {
                pub(crate) unsafe fn _lift(val: u8) -> HandSide {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => HandSide::Left,
                        1 => HandSide::Right,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Joint {
                pub translation: Vec3,
                pub rotation: Vec4,
                pub radius: f32,
            }
            impl ::core::fmt::Debug for Joint {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Joint")
                        .field("translation", &self.translation)
                        .field("rotation", &self.rotation)
                        .field("radius", &self.radius)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Finger {
                pub tip: Joint,
                pub distal: Joint,
                pub proximal: Joint,
                pub metacarpal: Joint,
            }
            impl ::core::fmt::Debug for Finger {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Finger")
                        .field("tip", &self.tip)
                        .field("distal", &self.distal)
                        .field("proximal", &self.proximal)
                        .field("metacarpal", &self.metacarpal)
                        .finish()
                }
            }
            /// Hand tracking data.
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Hand {
                pub side: HandSide,
                pub thumb: Finger,
                pub index: Finger,
                pub middle: Finger,
                pub ring: Finger,
                pub little: Finger,
                pub palm: Joint,
                pub wrist: Joint,
                pub elbow: Option<Joint>,
            }
            impl ::core::fmt::Debug for Hand {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Hand")
                        .field("side", &self.side)
                        .field("thumb", &self.thumb)
                        .field("index", &self.index)
                        .field("middle", &self.middle)
                        .field("ring", &self.ring)
                        .field("little", &self.little)
                        .field("palm", &self.palm)
                        .field("wrist", &self.wrist)
                        .field("elbow", &self.elbow)
                        .finish()
                }
            }
            /// A line with an origin and a direction.
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Ray {
                pub origin: Vec3,
                pub orientation: Vec4,
            }
            impl ::core::fmt::Debug for Ray {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Ray")
                        .field("origin", &self.origin)
                        .field("orientation", &self.orientation)
                        .finish()
                }
            }
            /// A single point of interaction, such as the tip of a stylus.
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Tip {
                pub origin: Vec3,
                pub orientation: Vec4,
                pub radius: f32,
            }
            impl ::core::fmt::Debug for Tip {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Tip")
                        .field("origin", &self.origin)
                        .field("orientation", &self.orientation)
                        .field("radius", &self.radius)
                        .finish()
                }
            }
            #[derive(Clone, Copy)]
            pub enum InputType {
                Hand(Hand),
                Ray(Ray),
                Tip(Tip),
            }
            impl ::core::fmt::Debug for InputType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        InputType::Hand(e) => f.debug_tuple("InputType::Hand").field(e).finish(),
                        InputType::Ray(e) => f.debug_tuple("InputType::Ray").field(e).finish(),
                        InputType::Tip(e) => f.debug_tuple("InputType::Tip").field(e).finish(),
                    }
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct InputEvent {
                /// Unique id for the event.
                pub id: u64,
                /// Spatial input data.
                pub input: InputType,
                /// Distance from the input method to the handler.
                pub distance: f32,
                /// How many handlers received the event before this one.
                pub order: u32,
            }
            impl ::core::fmt::Debug for InputEvent {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("InputEvent")
                        .field("id", &self.id)
                        .field("input", &self.input)
                        .field("distance", &self.distance)
                        .field("order", &self.order)
                        .finish()
                }
            }
        }

        #[allow(clippy::all)]
        pub mod handler {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type InputEvent = super::super::super::wired::input::types::InputEvent;
            pub type Node = super::super::super::wired::spatial::node::Node;
            /// Input handler.
            /// Represents an object in 3D space that can react to input.
            /// Handlers can optionally capture the input method, stopping propagation to other handlers.

            #[derive(Debug)]
            #[repr(transparent)]
            pub struct SpatialHandler {
                handle: _rt::Resource<SpatialHandler>,
            }

            impl SpatialHandler {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: _rt::Resource::from_handle(handle),
                    }
                }

                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }

                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }

            unsafe impl _rt::WasmResource for SpatialHandler {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();

                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wired:input/handler")]
                        extern "C" {
                            #[link_name = "[resource-drop]spatial-handler"]
                            fn drop(_: u32);
                        }

                        drop(_handle);
                    }
                }
            }

            impl SpatialHandler {
                #[allow(unused_unsafe, clippy::all)]
                /// The node that this handler is attached to.
                pub fn node(&self) -> Node {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wired:input/handler")]
                        extern "C" {
                            #[link_name = "[method]spatial-handler.node"]
                            fn wit_import(_: i32) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import((self).handle() as i32);
                        super::super::super::wired::spatial::node::Node::from_handle(ret as u32)
                    }
                }
            }
            impl SpatialHandler {
                #[allow(unused_unsafe, clippy::all)]
                /// Called when an input event is received.
                /// Return true to capture the event.
                pub fn on_input(&self, event: InputEvent) -> bool {
                    unsafe {
                        #[repr(align(8))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 776]);
                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 776]);
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        *ptr0.add(0).cast::<i32>() = (self).handle() as i32;
                        let super::super::super::wired::input::types::InputEvent {
                            id: id1,
                            input: input1,
                            distance: distance1,
                            order: order1,
                        } = event;
                        *ptr0.add(8).cast::<i64>() = _rt::as_i64(id1);
                        use super::super::super::wired::input::types::InputType as V83;
                        match input1 {
                            V83::Hand(e) => {
                                *ptr0.add(16).cast::<u8>() = (0i32) as u8;
                                let super::super::super::wired::input::types::Hand {
                                    side: side2,
                                    thumb: thumb2,
                                    index: index2,
                                    middle: middle2,
                                    ring: ring2,
                                    little: little2,
                                    palm: palm2,
                                    wrist: wrist2,
                                    elbow: elbow2,
                                } = e;
                                *ptr0.add(20).cast::<u8>() = (side2.clone() as i32) as u8;
                                let super::super::super::wired::input::types::Finger {
                                    tip: tip3,
                                    distal: distal3,
                                    proximal: proximal3,
                                    metacarpal: metacarpal3,
                                } = thumb2;
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation4,
                                    rotation: rotation4,
                                    radius: radius4,
                                } = tip3;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x5,
                                    y: y5,
                                    z: z5,
                                } = translation4;
                                *ptr0.add(24).cast::<f32>() = _rt::as_f32(x5);
                                *ptr0.add(28).cast::<f32>() = _rt::as_f32(y5);
                                *ptr0.add(32).cast::<f32>() = _rt::as_f32(z5);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x6,
                                    y: y6,
                                    z: z6,
                                    w: w6,
                                } = rotation4;
                                *ptr0.add(36).cast::<f32>() = _rt::as_f32(x6);
                                *ptr0.add(40).cast::<f32>() = _rt::as_f32(y6);
                                *ptr0.add(44).cast::<f32>() = _rt::as_f32(z6);
                                *ptr0.add(48).cast::<f32>() = _rt::as_f32(w6);
                                *ptr0.add(52).cast::<f32>() = _rt::as_f32(radius4);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation7,
                                    rotation: rotation7,
                                    radius: radius7,
                                } = distal3;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x8,
                                    y: y8,
                                    z: z8,
                                } = translation7;
                                *ptr0.add(56).cast::<f32>() = _rt::as_f32(x8);
                                *ptr0.add(60).cast::<f32>() = _rt::as_f32(y8);
                                *ptr0.add(64).cast::<f32>() = _rt::as_f32(z8);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x9,
                                    y: y9,
                                    z: z9,
                                    w: w9,
                                } = rotation7;
                                *ptr0.add(68).cast::<f32>() = _rt::as_f32(x9);
                                *ptr0.add(72).cast::<f32>() = _rt::as_f32(y9);
                                *ptr0.add(76).cast::<f32>() = _rt::as_f32(z9);
                                *ptr0.add(80).cast::<f32>() = _rt::as_f32(w9);
                                *ptr0.add(84).cast::<f32>() = _rt::as_f32(radius7);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation10,
                                    rotation: rotation10,
                                    radius: radius10,
                                } = proximal3;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x11,
                                    y: y11,
                                    z: z11,
                                } = translation10;
                                *ptr0.add(88).cast::<f32>() = _rt::as_f32(x11);
                                *ptr0.add(92).cast::<f32>() = _rt::as_f32(y11);
                                *ptr0.add(96).cast::<f32>() = _rt::as_f32(z11);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x12,
                                    y: y12,
                                    z: z12,
                                    w: w12,
                                } = rotation10;
                                *ptr0.add(100).cast::<f32>() = _rt::as_f32(x12);
                                *ptr0.add(104).cast::<f32>() = _rt::as_f32(y12);
                                *ptr0.add(108).cast::<f32>() = _rt::as_f32(z12);
                                *ptr0.add(112).cast::<f32>() = _rt::as_f32(w12);
                                *ptr0.add(116).cast::<f32>() = _rt::as_f32(radius10);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation13,
                                    rotation: rotation13,
                                    radius: radius13,
                                } = metacarpal3;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x14,
                                    y: y14,
                                    z: z14,
                                } = translation13;
                                *ptr0.add(120).cast::<f32>() = _rt::as_f32(x14);
                                *ptr0.add(124).cast::<f32>() = _rt::as_f32(y14);
                                *ptr0.add(128).cast::<f32>() = _rt::as_f32(z14);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x15,
                                    y: y15,
                                    z: z15,
                                    w: w15,
                                } = rotation13;
                                *ptr0.add(132).cast::<f32>() = _rt::as_f32(x15);
                                *ptr0.add(136).cast::<f32>() = _rt::as_f32(y15);
                                *ptr0.add(140).cast::<f32>() = _rt::as_f32(z15);
                                *ptr0.add(144).cast::<f32>() = _rt::as_f32(w15);
                                *ptr0.add(148).cast::<f32>() = _rt::as_f32(radius13);
                                let super::super::super::wired::input::types::Finger {
                                    tip: tip16,
                                    distal: distal16,
                                    proximal: proximal16,
                                    metacarpal: metacarpal16,
                                } = index2;
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation17,
                                    rotation: rotation17,
                                    radius: radius17,
                                } = tip16;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x18,
                                    y: y18,
                                    z: z18,
                                } = translation17;
                                *ptr0.add(152).cast::<f32>() = _rt::as_f32(x18);
                                *ptr0.add(156).cast::<f32>() = _rt::as_f32(y18);
                                *ptr0.add(160).cast::<f32>() = _rt::as_f32(z18);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x19,
                                    y: y19,
                                    z: z19,
                                    w: w19,
                                } = rotation17;
                                *ptr0.add(164).cast::<f32>() = _rt::as_f32(x19);
                                *ptr0.add(168).cast::<f32>() = _rt::as_f32(y19);
                                *ptr0.add(172).cast::<f32>() = _rt::as_f32(z19);
                                *ptr0.add(176).cast::<f32>() = _rt::as_f32(w19);
                                *ptr0.add(180).cast::<f32>() = _rt::as_f32(radius17);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation20,
                                    rotation: rotation20,
                                    radius: radius20,
                                } = distal16;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x21,
                                    y: y21,
                                    z: z21,
                                } = translation20;
                                *ptr0.add(184).cast::<f32>() = _rt::as_f32(x21);
                                *ptr0.add(188).cast::<f32>() = _rt::as_f32(y21);
                                *ptr0.add(192).cast::<f32>() = _rt::as_f32(z21);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x22,
                                    y: y22,
                                    z: z22,
                                    w: w22,
                                } = rotation20;
                                *ptr0.add(196).cast::<f32>() = _rt::as_f32(x22);
                                *ptr0.add(200).cast::<f32>() = _rt::as_f32(y22);
                                *ptr0.add(204).cast::<f32>() = _rt::as_f32(z22);
                                *ptr0.add(208).cast::<f32>() = _rt::as_f32(w22);
                                *ptr0.add(212).cast::<f32>() = _rt::as_f32(radius20);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation23,
                                    rotation: rotation23,
                                    radius: radius23,
                                } = proximal16;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x24,
                                    y: y24,
                                    z: z24,
                                } = translation23;
                                *ptr0.add(216).cast::<f32>() = _rt::as_f32(x24);
                                *ptr0.add(220).cast::<f32>() = _rt::as_f32(y24);
                                *ptr0.add(224).cast::<f32>() = _rt::as_f32(z24);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x25,
                                    y: y25,
                                    z: z25,
                                    w: w25,
                                } = rotation23;
                                *ptr0.add(228).cast::<f32>() = _rt::as_f32(x25);
                                *ptr0.add(232).cast::<f32>() = _rt::as_f32(y25);
                                *ptr0.add(236).cast::<f32>() = _rt::as_f32(z25);
                                *ptr0.add(240).cast::<f32>() = _rt::as_f32(w25);
                                *ptr0.add(244).cast::<f32>() = _rt::as_f32(radius23);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation26,
                                    rotation: rotation26,
                                    radius: radius26,
                                } = metacarpal16;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x27,
                                    y: y27,
                                    z: z27,
                                } = translation26;
                                *ptr0.add(248).cast::<f32>() = _rt::as_f32(x27);
                                *ptr0.add(252).cast::<f32>() = _rt::as_f32(y27);
                                *ptr0.add(256).cast::<f32>() = _rt::as_f32(z27);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x28,
                                    y: y28,
                                    z: z28,
                                    w: w28,
                                } = rotation26;
                                *ptr0.add(260).cast::<f32>() = _rt::as_f32(x28);
                                *ptr0.add(264).cast::<f32>() = _rt::as_f32(y28);
                                *ptr0.add(268).cast::<f32>() = _rt::as_f32(z28);
                                *ptr0.add(272).cast::<f32>() = _rt::as_f32(w28);
                                *ptr0.add(276).cast::<f32>() = _rt::as_f32(radius26);
                                let super::super::super::wired::input::types::Finger {
                                    tip: tip29,
                                    distal: distal29,
                                    proximal: proximal29,
                                    metacarpal: metacarpal29,
                                } = middle2;
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation30,
                                    rotation: rotation30,
                                    radius: radius30,
                                } = tip29;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x31,
                                    y: y31,
                                    z: z31,
                                } = translation30;
                                *ptr0.add(280).cast::<f32>() = _rt::as_f32(x31);
                                *ptr0.add(284).cast::<f32>() = _rt::as_f32(y31);
                                *ptr0.add(288).cast::<f32>() = _rt::as_f32(z31);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x32,
                                    y: y32,
                                    z: z32,
                                    w: w32,
                                } = rotation30;
                                *ptr0.add(292).cast::<f32>() = _rt::as_f32(x32);
                                *ptr0.add(296).cast::<f32>() = _rt::as_f32(y32);
                                *ptr0.add(300).cast::<f32>() = _rt::as_f32(z32);
                                *ptr0.add(304).cast::<f32>() = _rt::as_f32(w32);
                                *ptr0.add(308).cast::<f32>() = _rt::as_f32(radius30);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation33,
                                    rotation: rotation33,
                                    radius: radius33,
                                } = distal29;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x34,
                                    y: y34,
                                    z: z34,
                                } = translation33;
                                *ptr0.add(312).cast::<f32>() = _rt::as_f32(x34);
                                *ptr0.add(316).cast::<f32>() = _rt::as_f32(y34);
                                *ptr0.add(320).cast::<f32>() = _rt::as_f32(z34);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x35,
                                    y: y35,
                                    z: z35,
                                    w: w35,
                                } = rotation33;
                                *ptr0.add(324).cast::<f32>() = _rt::as_f32(x35);
                                *ptr0.add(328).cast::<f32>() = _rt::as_f32(y35);
                                *ptr0.add(332).cast::<f32>() = _rt::as_f32(z35);
                                *ptr0.add(336).cast::<f32>() = _rt::as_f32(w35);
                                *ptr0.add(340).cast::<f32>() = _rt::as_f32(radius33);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation36,
                                    rotation: rotation36,
                                    radius: radius36,
                                } = proximal29;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x37,
                                    y: y37,
                                    z: z37,
                                } = translation36;
                                *ptr0.add(344).cast::<f32>() = _rt::as_f32(x37);
                                *ptr0.add(348).cast::<f32>() = _rt::as_f32(y37);
                                *ptr0.add(352).cast::<f32>() = _rt::as_f32(z37);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x38,
                                    y: y38,
                                    z: z38,
                                    w: w38,
                                } = rotation36;
                                *ptr0.add(356).cast::<f32>() = _rt::as_f32(x38);
                                *ptr0.add(360).cast::<f32>() = _rt::as_f32(y38);
                                *ptr0.add(364).cast::<f32>() = _rt::as_f32(z38);
                                *ptr0.add(368).cast::<f32>() = _rt::as_f32(w38);
                                *ptr0.add(372).cast::<f32>() = _rt::as_f32(radius36);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation39,
                                    rotation: rotation39,
                                    radius: radius39,
                                } = metacarpal29;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x40,
                                    y: y40,
                                    z: z40,
                                } = translation39;
                                *ptr0.add(376).cast::<f32>() = _rt::as_f32(x40);
                                *ptr0.add(380).cast::<f32>() = _rt::as_f32(y40);
                                *ptr0.add(384).cast::<f32>() = _rt::as_f32(z40);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x41,
                                    y: y41,
                                    z: z41,
                                    w: w41,
                                } = rotation39;
                                *ptr0.add(388).cast::<f32>() = _rt::as_f32(x41);
                                *ptr0.add(392).cast::<f32>() = _rt::as_f32(y41);
                                *ptr0.add(396).cast::<f32>() = _rt::as_f32(z41);
                                *ptr0.add(400).cast::<f32>() = _rt::as_f32(w41);
                                *ptr0.add(404).cast::<f32>() = _rt::as_f32(radius39);
                                let super::super::super::wired::input::types::Finger {
                                    tip: tip42,
                                    distal: distal42,
                                    proximal: proximal42,
                                    metacarpal: metacarpal42,
                                } = ring2;
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation43,
                                    rotation: rotation43,
                                    radius: radius43,
                                } = tip42;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x44,
                                    y: y44,
                                    z: z44,
                                } = translation43;
                                *ptr0.add(408).cast::<f32>() = _rt::as_f32(x44);
                                *ptr0.add(412).cast::<f32>() = _rt::as_f32(y44);
                                *ptr0.add(416).cast::<f32>() = _rt::as_f32(z44);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x45,
                                    y: y45,
                                    z: z45,
                                    w: w45,
                                } = rotation43;
                                *ptr0.add(420).cast::<f32>() = _rt::as_f32(x45);
                                *ptr0.add(424).cast::<f32>() = _rt::as_f32(y45);
                                *ptr0.add(428).cast::<f32>() = _rt::as_f32(z45);
                                *ptr0.add(432).cast::<f32>() = _rt::as_f32(w45);
                                *ptr0.add(436).cast::<f32>() = _rt::as_f32(radius43);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation46,
                                    rotation: rotation46,
                                    radius: radius46,
                                } = distal42;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x47,
                                    y: y47,
                                    z: z47,
                                } = translation46;
                                *ptr0.add(440).cast::<f32>() = _rt::as_f32(x47);
                                *ptr0.add(444).cast::<f32>() = _rt::as_f32(y47);
                                *ptr0.add(448).cast::<f32>() = _rt::as_f32(z47);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x48,
                                    y: y48,
                                    z: z48,
                                    w: w48,
                                } = rotation46;
                                *ptr0.add(452).cast::<f32>() = _rt::as_f32(x48);
                                *ptr0.add(456).cast::<f32>() = _rt::as_f32(y48);
                                *ptr0.add(460).cast::<f32>() = _rt::as_f32(z48);
                                *ptr0.add(464).cast::<f32>() = _rt::as_f32(w48);
                                *ptr0.add(468).cast::<f32>() = _rt::as_f32(radius46);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation49,
                                    rotation: rotation49,
                                    radius: radius49,
                                } = proximal42;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x50,
                                    y: y50,
                                    z: z50,
                                } = translation49;
                                *ptr0.add(472).cast::<f32>() = _rt::as_f32(x50);
                                *ptr0.add(476).cast::<f32>() = _rt::as_f32(y50);
                                *ptr0.add(480).cast::<f32>() = _rt::as_f32(z50);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x51,
                                    y: y51,
                                    z: z51,
                                    w: w51,
                                } = rotation49;
                                *ptr0.add(484).cast::<f32>() = _rt::as_f32(x51);
                                *ptr0.add(488).cast::<f32>() = _rt::as_f32(y51);
                                *ptr0.add(492).cast::<f32>() = _rt::as_f32(z51);
                                *ptr0.add(496).cast::<f32>() = _rt::as_f32(w51);
                                *ptr0.add(500).cast::<f32>() = _rt::as_f32(radius49);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation52,
                                    rotation: rotation52,
                                    radius: radius52,
                                } = metacarpal42;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x53,
                                    y: y53,
                                    z: z53,
                                } = translation52;
                                *ptr0.add(504).cast::<f32>() = _rt::as_f32(x53);
                                *ptr0.add(508).cast::<f32>() = _rt::as_f32(y53);
                                *ptr0.add(512).cast::<f32>() = _rt::as_f32(z53);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x54,
                                    y: y54,
                                    z: z54,
                                    w: w54,
                                } = rotation52;
                                *ptr0.add(516).cast::<f32>() = _rt::as_f32(x54);
                                *ptr0.add(520).cast::<f32>() = _rt::as_f32(y54);
                                *ptr0.add(524).cast::<f32>() = _rt::as_f32(z54);
                                *ptr0.add(528).cast::<f32>() = _rt::as_f32(w54);
                                *ptr0.add(532).cast::<f32>() = _rt::as_f32(radius52);
                                let super::super::super::wired::input::types::Finger {
                                    tip: tip55,
                                    distal: distal55,
                                    proximal: proximal55,
                                    metacarpal: metacarpal55,
                                } = little2;
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation56,
                                    rotation: rotation56,
                                    radius: radius56,
                                } = tip55;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x57,
                                    y: y57,
                                    z: z57,
                                } = translation56;
                                *ptr0.add(536).cast::<f32>() = _rt::as_f32(x57);
                                *ptr0.add(540).cast::<f32>() = _rt::as_f32(y57);
                                *ptr0.add(544).cast::<f32>() = _rt::as_f32(z57);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x58,
                                    y: y58,
                                    z: z58,
                                    w: w58,
                                } = rotation56;
                                *ptr0.add(548).cast::<f32>() = _rt::as_f32(x58);
                                *ptr0.add(552).cast::<f32>() = _rt::as_f32(y58);
                                *ptr0.add(556).cast::<f32>() = _rt::as_f32(z58);
                                *ptr0.add(560).cast::<f32>() = _rt::as_f32(w58);
                                *ptr0.add(564).cast::<f32>() = _rt::as_f32(radius56);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation59,
                                    rotation: rotation59,
                                    radius: radius59,
                                } = distal55;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x60,
                                    y: y60,
                                    z: z60,
                                } = translation59;
                                *ptr0.add(568).cast::<f32>() = _rt::as_f32(x60);
                                *ptr0.add(572).cast::<f32>() = _rt::as_f32(y60);
                                *ptr0.add(576).cast::<f32>() = _rt::as_f32(z60);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x61,
                                    y: y61,
                                    z: z61,
                                    w: w61,
                                } = rotation59;
                                *ptr0.add(580).cast::<f32>() = _rt::as_f32(x61);
                                *ptr0.add(584).cast::<f32>() = _rt::as_f32(y61);
                                *ptr0.add(588).cast::<f32>() = _rt::as_f32(z61);
                                *ptr0.add(592).cast::<f32>() = _rt::as_f32(w61);
                                *ptr0.add(596).cast::<f32>() = _rt::as_f32(radius59);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation62,
                                    rotation: rotation62,
                                    radius: radius62,
                                } = proximal55;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x63,
                                    y: y63,
                                    z: z63,
                                } = translation62;
                                *ptr0.add(600).cast::<f32>() = _rt::as_f32(x63);
                                *ptr0.add(604).cast::<f32>() = _rt::as_f32(y63);
                                *ptr0.add(608).cast::<f32>() = _rt::as_f32(z63);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x64,
                                    y: y64,
                                    z: z64,
                                    w: w64,
                                } = rotation62;
                                *ptr0.add(612).cast::<f32>() = _rt::as_f32(x64);
                                *ptr0.add(616).cast::<f32>() = _rt::as_f32(y64);
                                *ptr0.add(620).cast::<f32>() = _rt::as_f32(z64);
                                *ptr0.add(624).cast::<f32>() = _rt::as_f32(w64);
                                *ptr0.add(628).cast::<f32>() = _rt::as_f32(radius62);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation65,
                                    rotation: rotation65,
                                    radius: radius65,
                                } = metacarpal55;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x66,
                                    y: y66,
                                    z: z66,
                                } = translation65;
                                *ptr0.add(632).cast::<f32>() = _rt::as_f32(x66);
                                *ptr0.add(636).cast::<f32>() = _rt::as_f32(y66);
                                *ptr0.add(640).cast::<f32>() = _rt::as_f32(z66);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x67,
                                    y: y67,
                                    z: z67,
                                    w: w67,
                                } = rotation65;
                                *ptr0.add(644).cast::<f32>() = _rt::as_f32(x67);
                                *ptr0.add(648).cast::<f32>() = _rt::as_f32(y67);
                                *ptr0.add(652).cast::<f32>() = _rt::as_f32(z67);
                                *ptr0.add(656).cast::<f32>() = _rt::as_f32(w67);
                                *ptr0.add(660).cast::<f32>() = _rt::as_f32(radius65);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation68,
                                    rotation: rotation68,
                                    radius: radius68,
                                } = palm2;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x69,
                                    y: y69,
                                    z: z69,
                                } = translation68;
                                *ptr0.add(664).cast::<f32>() = _rt::as_f32(x69);
                                *ptr0.add(668).cast::<f32>() = _rt::as_f32(y69);
                                *ptr0.add(672).cast::<f32>() = _rt::as_f32(z69);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x70,
                                    y: y70,
                                    z: z70,
                                    w: w70,
                                } = rotation68;
                                *ptr0.add(676).cast::<f32>() = _rt::as_f32(x70);
                                *ptr0.add(680).cast::<f32>() = _rt::as_f32(y70);
                                *ptr0.add(684).cast::<f32>() = _rt::as_f32(z70);
                                *ptr0.add(688).cast::<f32>() = _rt::as_f32(w70);
                                *ptr0.add(692).cast::<f32>() = _rt::as_f32(radius68);
                                let super::super::super::wired::input::types::Joint {
                                    translation: translation71,
                                    rotation: rotation71,
                                    radius: radius71,
                                } = wrist2;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x72,
                                    y: y72,
                                    z: z72,
                                } = translation71;
                                *ptr0.add(696).cast::<f32>() = _rt::as_f32(x72);
                                *ptr0.add(700).cast::<f32>() = _rt::as_f32(y72);
                                *ptr0.add(704).cast::<f32>() = _rt::as_f32(z72);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x73,
                                    y: y73,
                                    z: z73,
                                    w: w73,
                                } = rotation71;
                                *ptr0.add(708).cast::<f32>() = _rt::as_f32(x73);
                                *ptr0.add(712).cast::<f32>() = _rt::as_f32(y73);
                                *ptr0.add(716).cast::<f32>() = _rt::as_f32(z73);
                                *ptr0.add(720).cast::<f32>() = _rt::as_f32(w73);
                                *ptr0.add(724).cast::<f32>() = _rt::as_f32(radius71);
                                match elbow2 {
                                    Some(e) => {
                                        *ptr0.add(728).cast::<u8>() = (1i32) as u8;
                                        let super::super::super::wired::input::types::Joint {
                                            translation: translation74,
                                            rotation: rotation74,
                                            radius: radius74,
                                        } = e;
                                        let super::super::super::wired::math::types::Vec3 {
                                            x: x75,
                                            y: y75,
                                            z: z75,
                                        } = translation74;
                                        *ptr0.add(732).cast::<f32>() = _rt::as_f32(x75);
                                        *ptr0.add(736).cast::<f32>() = _rt::as_f32(y75);
                                        *ptr0.add(740).cast::<f32>() = _rt::as_f32(z75);
                                        let super::super::super::wired::math::types::Vec4 {
                                            x: x76,
                                            y: y76,
                                            z: z76,
                                            w: w76,
                                        } = rotation74;
                                        *ptr0.add(744).cast::<f32>() = _rt::as_f32(x76);
                                        *ptr0.add(748).cast::<f32>() = _rt::as_f32(y76);
                                        *ptr0.add(752).cast::<f32>() = _rt::as_f32(z76);
                                        *ptr0.add(756).cast::<f32>() = _rt::as_f32(w76);
                                        *ptr0.add(760).cast::<f32>() = _rt::as_f32(radius74);
                                    }
                                    None => {
                                        *ptr0.add(728).cast::<u8>() = (0i32) as u8;
                                    }
                                };
                            }
                            V83::Ray(e) => {
                                *ptr0.add(16).cast::<u8>() = (1i32) as u8;
                                let super::super::super::wired::input::types::Ray {
                                    origin: origin77,
                                    orientation: orientation77,
                                } = e;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x78,
                                    y: y78,
                                    z: z78,
                                } = origin77;
                                *ptr0.add(20).cast::<f32>() = _rt::as_f32(x78);
                                *ptr0.add(24).cast::<f32>() = _rt::as_f32(y78);
                                *ptr0.add(28).cast::<f32>() = _rt::as_f32(z78);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x79,
                                    y: y79,
                                    z: z79,
                                    w: w79,
                                } = orientation77;
                                *ptr0.add(32).cast::<f32>() = _rt::as_f32(x79);
                                *ptr0.add(36).cast::<f32>() = _rt::as_f32(y79);
                                *ptr0.add(40).cast::<f32>() = _rt::as_f32(z79);
                                *ptr0.add(44).cast::<f32>() = _rt::as_f32(w79);
                            }
                            V83::Tip(e) => {
                                *ptr0.add(16).cast::<u8>() = (2i32) as u8;
                                let super::super::super::wired::input::types::Tip {
                                    origin: origin80,
                                    orientation: orientation80,
                                    radius: radius80,
                                } = e;
                                let super::super::super::wired::math::types::Vec3 {
                                    x: x81,
                                    y: y81,
                                    z: z81,
                                } = origin80;
                                *ptr0.add(20).cast::<f32>() = _rt::as_f32(x81);
                                *ptr0.add(24).cast::<f32>() = _rt::as_f32(y81);
                                *ptr0.add(28).cast::<f32>() = _rt::as_f32(z81);
                                let super::super::super::wired::math::types::Vec4 {
                                    x: x82,
                                    y: y82,
                                    z: z82,
                                    w: w82,
                                } = orientation80;
                                *ptr0.add(32).cast::<f32>() = _rt::as_f32(x82);
                                *ptr0.add(36).cast::<f32>() = _rt::as_f32(y82);
                                *ptr0.add(40).cast::<f32>() = _rt::as_f32(z82);
                                *ptr0.add(44).cast::<f32>() = _rt::as_f32(w82);
                                *ptr0.add(48).cast::<f32>() = _rt::as_f32(radius80);
                            }
                        }
                        *ptr0.add(764).cast::<f32>() = _rt::as_f32(distance1);
                        *ptr0.add(768).cast::<i32>() = _rt::as_i32(order1);

                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wired:input/handler")]
                        extern "C" {
                            #[link_name = "[method]spatial-handler.on-input"]
                            fn wit_import(_: *mut u8) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: *mut u8) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import(ptr0);
                        _rt::bool_lift(ret as u8)
                    }
                }
            }
        }
    }
    pub mod math {

        #[allow(clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec3 {
                pub x: f32,
                pub y: f32,
                pub z: f32,
            }
            impl ::core::fmt::Debug for Vec3 {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Vec3")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Vec4 {
                pub x: f32,
                pub y: f32,
                pub z: f32,
                pub w: f32,
            }
            impl ::core::fmt::Debug for Vec4 {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Vec4")
                        .field("x", &self.x)
                        .field("y", &self.y)
                        .field("z", &self.z)
                        .field("w", &self.w)
                        .finish()
                }
            }
        }
    }
    pub mod spatial {

        #[allow(clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            pub type Vec3 = super::super::super::wired::math::types::Vec3;
            pub type Vec4 = super::super::super::wired::math::types::Vec4;
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Transform {
                pub translation: Vec3,
                pub rotation: Vec4,
                pub scale: Vec3,
            }
            impl ::core::fmt::Debug for Transform {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Transform")
                        .field("translation", &self.translation)
                        .field("rotation", &self.rotation)
                        .field("scale", &self.scale)
                        .finish()
                }
            }
        }

        #[allow(clippy::all)]
        pub mod node {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Transform = super::super::super::wired::spatial::types::Transform;

            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Node {
                handle: _rt::Resource<Node>,
            }

            impl Node {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: _rt::Resource::from_handle(handle),
                    }
                }

                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }

                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }

            unsafe impl _rt::WasmResource for Node {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();

                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wired:spatial/node")]
                        extern "C" {
                            #[link_name = "[resource-drop]node"]
                            fn drop(_: u32);
                        }

                        drop(_handle);
                    }
                }
            }

            impl Node {
                #[allow(unused_unsafe, clippy::all)]
                pub fn get_transform(&self) -> Transform {
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([::core::mem::MaybeUninit<u8>; 40]);
                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 40]);
                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wired:spatial/node")]
                        extern "C" {
                            #[link_name = "[method]node.get-transform"]
                            fn wit_import(_: i32, _: *mut u8);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: *mut u8) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32, ptr0);
                        let l1 = *ptr0.add(0).cast::<f32>();
                        let l2 = *ptr0.add(4).cast::<f32>();
                        let l3 = *ptr0.add(8).cast::<f32>();
                        let l4 = *ptr0.add(12).cast::<f32>();
                        let l5 = *ptr0.add(16).cast::<f32>();
                        let l6 = *ptr0.add(20).cast::<f32>();
                        let l7 = *ptr0.add(24).cast::<f32>();
                        let l8 = *ptr0.add(28).cast::<f32>();
                        let l9 = *ptr0.add(32).cast::<f32>();
                        let l10 = *ptr0.add(36).cast::<f32>();
                        super::super::super::wired::spatial::types::Transform {
                            translation: super::super::super::wired::math::types::Vec3 {
                                x: l1,
                                y: l2,
                                z: l3,
                            },
                            rotation: super::super::super::wired::math::types::Vec4 {
                                x: l4,
                                y: l5,
                                z: l6,
                                w: l7,
                            },
                            scale: super::super::super::wired::math::types::Vec3 {
                                x: l8,
                                y: l9,
                                z: l10,
                            },
                        }
                    }
                }
            }
            impl Node {
                #[allow(unused_unsafe, clippy::all)]
                pub fn set_transform(&self, transform: Transform) {
                    unsafe {
                        let super::super::super::wired::spatial::types::Transform {
                            translation: translation0,
                            rotation: rotation0,
                            scale: scale0,
                        } = transform;
                        let super::super::super::wired::math::types::Vec3 {
                            x: x1,
                            y: y1,
                            z: z1,
                        } = translation0;
                        let super::super::super::wired::math::types::Vec4 {
                            x: x2,
                            y: y2,
                            z: z2,
                            w: w2,
                        } = rotation0;
                        let super::super::super::wired::math::types::Vec3 {
                            x: x3,
                            y: y3,
                            z: z3,
                        } = scale0;

                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wired:spatial/node")]
                        extern "C" {
                            #[link_name = "[method]node.set-transform"]
                            fn wit_import(
                                _: i32,
                                _: f32,
                                _: f32,
                                _: f32,
                                _: f32,
                                _: f32,
                                _: f32,
                                _: f32,
                                _: f32,
                                _: f32,
                                _: f32,
                            );
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(
                            _: i32,
                            _: f32,
                            _: f32,
                            _: f32,
                            _: f32,
                            _: f32,
                            _: f32,
                            _: f32,
                            _: f32,
                            _: f32,
                            _: f32,
                        ) {
                            unreachable!()
                        }
                        wit_import(
                            (self).handle() as i32,
                            _rt::as_f32(x1),
                            _rt::as_f32(y1),
                            _rt::as_f32(z1),
                            _rt::as_f32(x2),
                            _rt::as_f32(y2),
                            _rt::as_f32(z2),
                            _rt::as_f32(w2),
                            _rt::as_f32(x3),
                            _rt::as_f32(y3),
                            _rt::as_f32(z3),
                        );
                    }
                }
            }
        }
    }
}
pub mod exports {
    pub mod unavi {
        pub mod ui {

            #[allow(clippy::all)]
            pub mod api {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;

                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_new_bubble_cabi<T: Guest>() -> *mut u8 {
                    let result0 = T::new_bubble();
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }

                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_new_bubble<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                pub trait Guest {
                    fn new_bubble() -> _rt::String;
                }
                #[doc(hidden)]

                macro_rules! __export_unavi_ui_api_cabi{
          ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {


            #[export_name = "unavi:ui/api#new-bubble"]
            unsafe extern "C" fn export_new_bubble() -> *mut u8 {
              $($path_to_types)*::_export_new_bubble_cabi::<$ty>()
            }

            #[export_name = "cabi_post_unavi:ui/api#new-bubble"]
            unsafe extern "C" fn _post_return_new_bubble(arg0: *mut u8,) {
              $($path_to_types)*::__post_return_new_bubble::<$ty>(arg0)
            }
          };);
        }
                #[doc(hidden)]
                pub(crate) use __export_unavi_ui_api_cabi;

                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }
        }
    }
}
mod _rt {

    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};

    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        // NB: This would ideally be `u32` but it is not. The fact that this has
        // interior mutability is not exposed in the API of this type except for the
        // `take_handle` method which is supposed to in theory be private.
        //
        // This represents, almost all the time, a valid handle value. When it's
        // invalid it's stored as `u32::MAX`.
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }

    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }

    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }

        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }

        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }

    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource")
                .field("handle", &self.handle)
                .finish()
        }
    }

    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    // If this handle was "taken" then don't do anything in the
                    // destructor.
                    u32::MAX => {}

                    // ... but otherwise do actually destroy it with the imported
                    // component model intrinsic as defined through `T`.
                    other => T::drop(other),
                }
            }
        }
    }

    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }

    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }

    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }

    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }

    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }

    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }

    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }

    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }

    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }

    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }

    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }

    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }

    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            ::core::mem::transmute::<u8, bool>(val)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }
    pub use alloc_crate::alloc;
    pub use alloc_crate::string::String;
    extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_host_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::unavi::ui::api::__export_unavi_ui_api_cabi!($ty with_types_in $($path_to_types_root)*::exports::unavi::ui::api);
  )
}
#[doc(inline)]
pub(crate) use __export_host_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.20.0:host:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1201] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xb6\x08\x01A\x02\x01\
A\x11\x01B\x06\x01r\x02\x01xv\x01yv\x04\0\x04vec2\x03\0\0\x01r\x03\x01xv\x01yv\x01\
zv\x04\0\x04vec3\x03\0\x02\x01r\x04\x01xv\x01yv\x01zv\x01wv\x04\0\x04vec4\x03\0\x04\
\x03\x01\x10wired:math/types\x05\0\x02\x03\0\0\x04vec3\x02\x03\0\0\x04vec4\x01B\x06\
\x02\x03\x02\x01\x01\x04\0\x04vec3\x03\0\0\x02\x03\x02\x01\x02\x04\0\x04vec4\x03\
\0\x02\x01r\x03\x0btranslation\x01\x08rotation\x03\x05scale\x01\x04\0\x09transfo\
rm\x03\0\x04\x03\x01\x13wired:spatial/types\x05\x03\x02\x03\0\x01\x09transform\x01\
B\x08\x02\x03\x02\x01\x04\x04\0\x09transform\x03\0\0\x04\0\x04node\x03\x01\x01h\x02\
\x01@\x01\x04self\x03\0\x01\x04\0\x1a[method]node.get-transform\x01\x04\x01@\x02\
\x04self\x03\x09transform\x01\x01\0\x04\0\x1a[method]node.set-transform\x01\x05\x03\
\x01\x12wired:spatial/node\x05\x05\x01B\x15\x02\x03\x02\x01\x01\x04\0\x04vec3\x03\
\0\0\x02\x03\x02\x01\x02\x04\0\x04vec4\x03\0\x02\x01m\x02\x04left\x05right\x04\0\
\x09hand-side\x03\0\x04\x01r\x03\x0btranslation\x01\x08rotation\x03\x06radiusv\x04\
\0\x05joint\x03\0\x06\x01r\x04\x03tip\x07\x06distal\x07\x08proximal\x07\x0ametac\
arpal\x07\x04\0\x06finger\x03\0\x08\x01k\x07\x01r\x09\x04side\x05\x05thumb\x09\x05\
index\x09\x06middle\x09\x04ring\x09\x06little\x09\x04palm\x07\x05wrist\x07\x05el\
bow\x0a\x04\0\x04hand\x03\0\x0b\x01r\x02\x06origin\x01\x0borientation\x03\x04\0\x03\
ray\x03\0\x0d\x01r\x03\x06origin\x01\x0borientation\x03\x06radiusv\x04\0\x03tip\x03\
\0\x0f\x01q\x03\x04hand\x01\x0c\0\x03ray\x01\x0e\0\x03tip\x01\x10\0\x04\0\x0ainp\
ut-type\x03\0\x11\x01r\x04\x02idw\x05input\x12\x08distancev\x05ordery\x04\0\x0bi\
nput-event\x03\0\x13\x03\x01\x11wired:input/types\x05\x06\x02\x03\0\x03\x0binput\
-event\x02\x03\0\x02\x04node\x01B\x0b\x02\x03\x02\x01\x07\x04\0\x0binput-event\x03\
\0\0\x02\x03\x02\x01\x08\x04\0\x04node\x03\0\x02\x04\0\x0fspatial-handler\x03\x01\
\x01h\x04\x01i\x03\x01@\x01\x04self\x05\0\x06\x04\0\x1c[method]spatial-handler.n\
ode\x01\x07\x01@\x02\x04self\x05\x05event\x01\0\x7f\x04\0\x20[method]spatial-han\
dler.on-input\x01\x08\x03\x01\x13wired:input/handler\x05\x09\x01B\x02\x01@\0\0s\x04\
\0\x0anew-bubble\x01\0\x04\x01\x0cunavi:ui/api\x05\x0a\x04\x01\x0dunavi:ui/host\x04\
\0\x0b\x0a\x01\0\x04host\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-\
component\x070.201.0\x10wit-bindgen-rust\x060.20.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
